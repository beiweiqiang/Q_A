# 数据结构 与 算法

## 冒泡排序

### 理解

从左到右, 不断交换相邻两个逆序的元素

经过一轮以后, 最大的元素会到达最右侧

如果经过一轮, 并没有发生过元素交换, 证明原来的排序是有序的, 可以退出

### 代码实现

可以分为三个点进行实现

1. 如果逆序, 相邻元素进行交换

```js
if (a[j] > a[j + 1]) {
  let tmp = a[j];
  a[j] = a[j + 1];
  a[j + 1] = tmp;
}
```

1. j 从 0 开始, 第一轮, 交换 i / len - 1 次 (比如有4个数, 则要交换3次), 其中, j 的范围是 [0, len - 2]

```js
for (let j = 0; j < i; j++) {}
```

3. i 表示要冒泡多少个元素, 第一轮中, 要冒泡 len - 1 个元素 (剩下1个不需要), 其中, i 的范围是 [0, len - 2]

```js
for (let i = len - 1; i > 0; i--) {}
```

4. 为什么 i 和 j 的范围都是 [0, len - 2] ?

循环有 2 层, 内层是交换的次数, 需要交换 len - 1 次, 外层是需要进行冒泡的元素的个数, 需要冒泡 len - 1 个.

但是 i 和 j 都是索引, 从 0 开始的, 所以 (len - 1) - 1.

1. 结合起来

```js
for (let i = len - 1; i > 0; i--) {
  for (let j = 0; j < i; j++) {
    if (a[j] > a[j + 1]) {
      let tmp = a[j];
      a[j] = a[j + 1];
      a[j + 1] = tmp;
    }
  }
}
```

### 上面的代码实现还可以如何改进 ?

如果在冒泡的一轮内 (会进行 len - 1 轮冒泡), 没有发生过交换, 可以认为剩余元素 (为什么说剩余呢 ? 会进行 len - 1 轮的冒泡操作, 在某一轮内, 只要不发生交换行为, 证明右侧部分的剩余元素已经是有序的) 已经是有序的.

我们使用 change 进行标记

```js
let change = true;
for (let i = len - 1; i > 0 && change; i--) {  // 如果冒泡的一轮中发生了交换, 则需要继续下一轮冒泡
  change = false;  // 假设不会进行交换
  for (let j = 0; j < i; j++) {
    if (a[j] > a[j + 1]) {
      change = true;  // 进行了交换, 设为 true
      let tmp = a[j];
      a[j] = a[j + 1];
      a[j + 1] = tmp;
    }
  }
}
```
