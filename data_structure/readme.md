# 数据结构 与 算法

## 选择排序

### 理解

选择出数组中最小的元素, 将它与数组的第一个元素进行交换.

再从剩下的元素中选择出最小的元素, 将它与数组的第二个元素进行交换.

这样不断进行.

### 代码实现

1. 外层循环, `a[i]` 元素作为最小的元素, 总共要进行 len - 1 次选择, 即 `i` (`i` 是索引) 的取值范围是 *[0, len - 2]*, 剩下最后一个元素不用进行选择

```js
let min;
for (let i = 0; i < len - 1; i++) {
  min = i;
}
```

2. 内层循环, 因为将 `i` 赋值为最小值 `min`, 将 `i` 右侧的元素与 `min` 进行比较, 如果比 `a[min]` 小, 则重新赋值 `min`, 总共要进行 len - 1 次比较, 即 `j` (`j` 是索引) 的取值范围是 *[1, len - 1]*, 第一个元素不用与自身比较

```js
for (let j = i + 1; j < len; j++) {
  if (a[j] < a[min]) {
    min = j;
  }
}
```

3. 如果 `min` 值不是一开始赋值的 `i`, 则证明 `a[i]` 不是剩余数组元素中的最小值, 需要进行交换

```js
if (min !== i) {
  let tmp = a[i];
  a[i] = a[min];
  a[min] = tmp;
}
```

4. 结合起来

```js
let min;
for (let i = 0; i < len - 1; i++) {
  min = i;

  for (let j = i + 1; j < len; j++) {
    if (a[j] < a[min]) {
      min = j;
    }
  }

  if (min !== i) {
    let tmp = a[i];
    a[i] = a[min];
    a[min] = tmp;
  }
}
```

### 时间复杂度 ? 空间复杂度 ?

需要大约 N^2/2 次比较, 需要大约 N 次交换.

## 冒泡排序

### 理解

从左到右, 不断交换相邻两个逆序的元素

经过一轮以后, 最大的元素会到达最右侧

(如果经过一轮, 并没有发生过元素交换, 证明原来的排序是有序的, 可以退出)

### 代码实现

可以分为三个点进行实现

1. 如果逆序, 相邻元素进行交换

```js
if (a[j] > a[j + 1]) {
  let tmp = a[j];
  a[j] = a[j + 1];
  a[j + 1] = tmp;
}
```

2. 内层循环, `j` 从 0 开始, 第一轮, 交换 i / len - 1 次 (比如有4个数, 则要交换3次), 其中, `j` 的范围是 *[0, len - 2]*

```js
for (let j = 0; j < i; j++) {}
```

3. 外层循环, `i` 表示要冒泡多少个元素, 第一轮中, 要冒泡 len - 1 个元素 (剩下1个不需要), 其中, `i` 的范围是 *[0, len - 2]*

```js
for (let i = len - 1; i > 0; i--) {}
```

4. 为什么 `i` 和 `j` 的范围都是 [0, len - 2] ?

循环有 2 层, 内层是交换的次数, 需要交换 len - 1 次, 外层是需要进行冒泡的元素的个数, 需要冒泡 len - 1 个.

但是 `i` 和 `j` 都是索引, 从 0 开始的, 所以是 (len - 1) - 1.

5. 结合起来

```js
for (let i = len - 1; i > 0; i--) {
  for (let j = 0; j < i; j++) {
    if (a[j] > a[j + 1]) {
      let tmp = a[j];
      a[j] = a[j + 1];
      a[j + 1] = tmp;
    }
  }
}
```

### 上面的代码实现还可以如何改进 ?

如果在冒泡的一轮内 (总共进行 len - 1 轮冒泡), 没有发生过交换, 可以认为剩余元素 (为什么说剩余呢 ? 总共进行 len - 1 轮的冒泡操作, 在某一轮内, 只要不发生交换行为, 证明右侧部分的剩余元素已经是有序的) 已经是有序的.

我们使用 `change` 进行标记

```js
let change = true;
for (let i = len - 1; i > 0 && change; i--) {  // 如果冒泡的一轮中发生了交换, 则需要继续下一轮冒泡
  change = false;  // 假设不会进行交换
  for (let j = 0; j < i; j++) {
    if (a[j] > a[j + 1]) {
      change = true;  // 进行了交换, 设为 true
      let tmp = a[j];
      a[j] = a[j + 1];
      a[j + 1] = tmp;
    }
  }
}
```

### 时间复杂度 ? 空间复杂度 ?

