
# 面向对象

## object 和 class 有什么区别 ?

|     | object | class |
| --- |:---|:---|
| 1 | object 是 class 的实例 | class 是 object 的模板/蓝图 |
| 2 | object 是真实世界的实体 | class 是一组相似 object 的集合 |
| 3 | 物理实体 | 逻辑实体 |
| 4 | 通过 new 关键字进行创建 | 通过 class 关键字进行声明 |
| 5 | 可创建多次 | 只会声明一次 |
| 6 | 创建时会分配内存 | 声明时不会分配内存 |

## 什么是面向对象 ?

面向对象是一种程序开发的 **编程范式**

传统的面向过程: 针对函数进行编程, 可看作是给计算机下达一系列的指令

面向对象是基于 *对象* 的一种编程范式, 把程序看成是一系列互相作用的对象, 对象包含了 *数据*, 以及 *对数据的操作*

对象会将数据进行封装, 外部只能通过对象暴露出来的操作来改变对象的数据

面向对象的目标是: 提升程序的 *可扩展性* 和 *可维护性*.

## 面向对象 vs 面向过程 ?

- 面向对象软件开发基于 *模块*, 代码耦合性低
- 面向对象基于 *模块* 进行开发, 测试更简单

## 什么是 编程范式 ?

范式 指 模式, 方法. 编程范式指编程风格. 如: 函数式编程, 面向对象编程, 指令编程...
编程范式决定了程序员对程序执行的看法.
如, 面向对象编程中, 程序员认为程序是一系列互相作用的对象.
函数式编程中, 程序是无状态的函数计算的序列
不同的编程语言会提倡不同的编程范式, 如 Java 面向对象, Haskell 函数式编程

## 面向对象的特征是什么 ?

封装, 继承, 多态

## 什么是 封装 ?

利用抽象数据类型将 *数据* 和 *基于数据的操作* 封装在一起, 使其构成一个不可分割的独立实体.

数据被保护在抽象数据类型的内部, 尽可能地隐藏内部的细节, 只保留一些对外接口使之与外部发生联系. 用户无需知道对象内部的细节, 可以使用对象对外提供的接口来访问对象.

```js
class Person {
  constructor() {
    this.name = '';
  }

  setName(name) {
    this.name = name;
  }

  getName() {
    return this.name;
  }
}

const p = new Person();
p.setName('heanqi');
p.getName();
```

## 封装的优点 ?

- 降低耦合: 独立的开发, 测试, 调试
- 降低维护成本: 以模块为单元进行调试, 不影响其他模块
- 提高代码可复用性

## 什么是继承 ?

继承实现了 is-a 的关系, 子类对象可以替换父类对象.

比如: `Animal animal = new Cat()`

以上, `Cat` 可以当做 `Animal` 来使用, 也就是说使用 `Animal` 引用 `Cat` 对象.

*父类引用* 指向 *子类对象* 称为 *向上转型*.

继承是多态的条件.

## 继承的优点 ?

- 子类自动继承父类的接口
- 提高代码可复用性

## 什么是多态 ?

多态分为 *编译时多态* 和 *运行时多态*.
- 编译时多态: 方法的重载
- 运行时多态: 程序中定义的 *对象引用所指向的具体类型* 在运行期间才确定

多态 指 不同对象中同种行为的不同实现形式.

## 运行时多态 的三个条件 ?

- 继承
- 覆盖 (重写)
- 向上转型

eg:
```js
class Person {
  say() {
    console.log('person');
  }
}

class Student extends Person {
  say() {
    console.log('student');
  }
}

class Teacher extends Person {
  say() {
    console.log('teacher');
  }
}

const arr = [];
arr.push(new Person());
arr.push(new Student());
arr.push(new Teacher())
arr.forEach(i => i.say());
```

## 多态的优点 ?

- 扩展性
